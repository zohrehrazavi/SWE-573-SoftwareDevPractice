<!DOCTYPE html>
<html>
  <head>
    <title>{{ board.name }}</title>
    <script src="https://unpkg.com/cytoscape/dist/cytoscape.min.js"></script>
    {% load static %}
    <link rel="stylesheet" href="{% static 'css/board_detail.css' %}" />
  </head>
  <body>
    <div class="main-container">
      <div class="board-header">
        <div class="board-title">{{ board.name }}</div>
        <div class="board-description-container">
          <div
            class="board-description {% if board.owner == user %}editable{% endif %}"
            id="board-description"
            data-description="{{ board.description|default:'' }}"
          >
            {% if board.description %}
            <div class="description-content">{{ board.description }}</div>
            {% elif board.owner == user %}
            <span class="placeholder">Add a description...</span>
            {% else %}
            <span class="placeholder">No description available</span>
            {% endif %}
          </div>
          {% if board.owner == user %}
          <button class="edit-description-btn" id="edit-description-btn">
            <svg
              width="16"
              height="16"
              viewBox="0 0 24 24"
              fill="none"
              stroke="currentColor"
              stroke-width="2"
            >
              <path
                d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"
              ></path>
              <path
                d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"
              ></path>
            </svg>
          </button>
          {% endif %}
        </div>
        <div class="board-meta">Created at: {{ board.created_at }}</div>
        {% if board.board_tags %}
        <div class="board-tags">
          {% for tag in board.board_tags %}
          <span class="tag-pill">{{ tag }}</span>
          {% endfor %}
        </div>
        {% endif %} {% if board.owner == user %}
        <a href="{% url 'edit_board' board.id %}" class="edit-board-btn">
          Edit Board
        </a>
        {% endif %}
      </div>
      <div class="accordion">
        <div class="accordion-header collapsed" id="nodesAccordionHeader">
          Nodes on this board
          <span class="arrow">&#9654;</span>
        </div>
        <div class="accordion-content" id="nodesAccordionContent">
          {% if nodes %} {% for node in nodes %}
          <div class="node-card">
            {% if board.owner == user %}
            <a href="{% url 'node_detail' node.id %}">{{ node.name }}</a>
            {% else %}
            <span
              style="color: #2563eb; font-weight: 600; cursor: not-allowed;"
            >
              {{ node.name }}
            </span>
            {% endif %} {% if node.properties %}
            <span style="color: #10b981; font-size: 0.95em;">(Enriched)</span>
            {% endif %} {% if board.owner == user %}
            <a
              href="{% url 'delete_node' node.id %}"
              class="delete-btn"
              style="margin-left: 10px; color: #e11d48; font-size: 1.1em;"
              title="Delete node"
              onclick="return confirm('Are you sure you want to delete this node?');"
            >
              <i class="fas fa-trash-alt"></i>
            </a>
            {% elif node.created_by_id == user.id %}
            <a
              href="{% url 'delete_node' node.id %}"
              class="delete-btn"
              style="margin-left: 10px; color: #e11d48; font-size: 1.1em;"
              title="Delete node"
              onclick="return confirm('Are you sure you want to delete this node?');"
            >
              <i class="fas fa-trash-alt"></i>
            </a>
            {% endif %}
          </div>
          {% endfor %} {% else %}
          <p style="margin: 0;">No nodes yet.</p>
          {% endif %}
        </div>
      </div>
      {% if is_board_editor %}
      <a href="{% url 'create_node' board.id %}" class="add-node-btn">
        + Add New Node
      </a>
      {% endif %}
      <a href="{% url 'home' %}" class="back-btn">← Back to Home</a>
      <div class="controls">
        <div class="mode-button" id="viewMode">View Properties</div>
        {% if is_board_editor %}
        <div class="mode-button" id="connectMode">Connect Nodes</div>
        {% endif %} {% if board.owner == user %}
        <div class="delete-button" id="deleteEdge">Delete Connection</div>
        {% endif %}
      </div>
      <div id="cy"></div>
      {% if not is_board_editor %}
      <div id="editRequestStatusArea">
        <button class="ask-edit-btn" id="askEditBtn">Ask for Edit</button>
      </div>
      <div id="askEditModal" class="modal">
        <div class="modal-content">
          <span class="close" id="closeAskEdit">&times;</span>
          <h3>Request Edit Access</h3>
          <textarea
            id="editRequestMsg"
            rows="3"
            style="width: 100%; margin-bottom: 12px;"
            placeholder="Why do you want to edit this board?"
          ></textarea>
          <button id="sendEditRequest" class="add-node-btn">
            Send Request
          </button>
          <div
            id="editRequestSentMsg"
            style="display: none; color: #10b981; margin-top: 10px;"
          >
            Your message was sent, please wait for accept.
          </div>
        </div>
      </div>
      {% endif %}
    </div>

    <div class="chat-sidebar">
      <div class="chat-header">
        <span>Number of Contributors: {{ contributors|length }}</span>
        <div class="dropdown">
          <button class="dropdown-toggle">Contributors Names ▼</button>
          <ul class="dropdown-menu">
            {% for user in contributors %}
            <li>{{ user.username }}</li>
            {% endfor %}
          </ul>
        </div>
      </div>
      <div class="chat-feed" id="chat-feed">
        {% for message in messages %}
        <div
          class="chat-message {% if message.user == user %}own-message{% endif %}"
          data-id="{{ message.id }}"
        >
          <span class="chat-user">{{ message.user.username }}</span>
          <span class="chat-content">{{ message.content }}</span>
          <span class="chat-time">{{ message.created_at|date:"H:i" }}</span>
          {% if message.user == user %}
          <button class="edit-btn">Edit</button>
          <button class="delete-btn">Delete</button>
          {% endif %}
        </div>
        {% endfor %}
      </div>
      <div class="chat-input">
        <textarea id="chat-text" maxlength="500"></textarea>
        <button id="send-btn">Send</button>
      </div>
    </div>

    <!-- Node Details Modal -->
    <div id="nodeModal" class="modal">
      <div class="modal-content">
        <span class="close">&times;</span>
        <h2 id="nodeName"></h2>
        <div id="nodeProperties" class="property-list"></div>
      </div>
    </div>

    <!-- Floating chat open button for mobile -->
    <button id="open-chat-btn" class="open-chat-btn" style="display: none;">
      <svg
        width="28"
        height="28"
        viewBox="0 0 24 24"
        fill="none"
        stroke="#fff"
        stroke-width="2"
        stroke-linecap="round"
        stroke-linejoin="round"
      >
        <path
          d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z"
        />
      </svg>
    </button>

    <script>
      document.addEventListener('DOMContentLoaded', function () {
        const boardId = '{{ board.id }}'
        const csrfToken = '{{ csrf_token }}'

        // Description editing functionality
        const descriptionContainer = document.getElementById(
          'board-description',
        )
        const editDescriptionBtn = document.getElementById(
          'edit-description-btn',
        )

        if (editDescriptionBtn) {
          editDescriptionBtn.addEventListener('click', function () {
            // Get the description from the data attribute
            const currentText = descriptionContainer.dataset.description || ''

            const textarea = document.createElement('textarea')
            textarea.value = currentText
            textarea.maxLength = 500
            textarea.className = 'description-edit-textarea'
            textarea.placeholder =
              'Enter board description (max 500 characters)'

            const saveBtn = document.createElement('button')
            saveBtn.textContent = 'Save'
            saveBtn.className = 'save-description-btn'

            const cancelBtn = document.createElement('button')
            cancelBtn.textContent = 'Cancel'
            cancelBtn.className = 'cancel-description-btn'

            const buttonContainer = document.createElement('div')
            buttonContainer.className = 'description-edit-buttons'
            buttonContainer.appendChild(saveBtn)
            buttonContainer.appendChild(cancelBtn)

            const originalContent = descriptionContainer.innerHTML
            descriptionContainer.innerHTML = ''
            descriptionContainer.appendChild(textarea)
            descriptionContainer.appendChild(buttonContainer)

            textarea.focus()

            saveBtn.addEventListener('click', function () {
              const newDescription = textarea.value.trim()
              fetch(`/auth/api/boards/${boardId}/update_description/`, {
                method: 'POST',
                headers: {
                  'Content-Type': 'application/x-www-form-urlencoded',
                  'X-CSRFToken': csrfToken,
                },
                body: `description=${encodeURIComponent(newDescription)}`,
              })
                .then((response) => response.json())
                .then((data) => {
                  if (data.success) {
                    descriptionContainer.dataset.description = newDescription
                    if (newDescription) {
                      descriptionContainer.innerHTML =
                        '<div class="description-content">' +
                        newDescription +
                        '</div>'
                    } else {
                      descriptionContainer.innerHTML =
                        '<span class="placeholder">Add a description...</span>'
                    }
                  } else {
                    alert(data.error || 'Failed to update description')
                    descriptionContainer.innerHTML = originalContent
                  }
                })
                .catch((error) => {
                  console.error('Error:', error)
                  alert('Failed to update description')
                  descriptionContainer.innerHTML = originalContent
                })
            })

            cancelBtn.addEventListener('click', function () {
              descriptionContainer.innerHTML = originalContent
            })
          })
        }

        let selectedNode = null
        let selectedEdge = null
        let isConnectMode = false
        const modal = document.getElementById('nodeModal')
        const closeBtns = document.getElementsByClassName('close')
        const viewModeBtn = document.getElementById('viewMode')
        const connectModeBtn = document.getElementById('connectMode')
        const deleteEdgeBtn = document.getElementById('deleteEdge')
        let cy = null

        function clearSelectedEdge() {
          if (selectedEdge && typeof selectedEdge.removeClass === 'function') {
            selectedEdge.removeClass('selected')
            selectedEdge = null
          }
          if (deleteEdgeBtn) {
            deleteEdgeBtn.classList.remove('active')
          }
        }

        // Mode switching
        if (viewModeBtn) {
          viewModeBtn.addEventListener('click', () => {
            isConnectMode = false
            viewModeBtn.classList.add('active')
            if (connectModeBtn) connectModeBtn.classList.remove('active')
            if (selectedNode) {
              selectedNode.removeClass('selected')
              selectedNode = null
            }
            clearSelectedEdge()
          })
        }

        if (connectModeBtn) {
          connectModeBtn.addEventListener('click', () => {
            isConnectMode = true
            connectModeBtn.classList.add('active')
            if (viewModeBtn) viewModeBtn.classList.remove('active')
            if (selectedNode) {
              selectedNode.removeClass('selected')
              selectedNode = null
            }
            clearSelectedEdge()
          })
        }

        // Delete edge button click handler
        if (deleteEdgeBtn) {
          deleteEdgeBtn.addEventListener('click', () => {
            if (selectedEdge) {
              const sourceNode = cy.getElementById(selectedEdge.data('source'))
              const targetNode = cy.getElementById(selectedEdge.data('target'))

              if (confirm('Are you sure you want to delete this connection?')) {
                fetch('/api/edge/delete/', {
                  method: 'POST',
                  headers: {
                    'X-CSRFToken': csrfToken,
                    'Content-Type': 'application/x-www-form-urlencoded',
                  },
                  credentials: 'include',
                  body: `from=${sourceNode.id()}&to=${targetNode.id()}&board=${boardId}`,
                })
                  .then((response) => {
                    if (!response.ok)
                      throw new Error('Network response was not ok')
                    return response.json()
                  })
                  .then((data) => {
                    if (data.status === 'deleted') {
                      cy.remove(selectedEdge)
                      clearSelectedEdge()
                    } else {
                      throw new Error(
                        data.message || 'Failed to delete connection',
                      )
                    }
                  })
                  .catch((error) => {
                    console.error('Error:', error)
                    alert('Failed to delete connection: ' + error.message)
                  })
              }
            }
          })
        }

        // Close modal when clicking the X
        for (let i = 0; i < closeBtns.length; i++) {
          closeBtns[i].onclick = function () {
            // Find the closest parent with class 'modal' and hide it
            let modal = this.closest('.modal')
            if (modal) {
              modal.style.display = 'none'
            }
          }
        }

        // Close modal when clicking outside of it
        window.onclick = function (event) {
          if (event.target == modal) {
            modal.style.display = 'none'
          }
        }

        function loadGraph() {
          fetch(`/api/board/${boardId}/graph/`)
            .then((response) => {
              if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`)
              }
              return response.json()
            })
            .then((data) => {
              const elements = []

              // Assign user colors
              const userColorMap = {}
              const colorPalette = [
                '#8e44ad', // purple
                '#16a085', // teal
                '#e67e22', // orange
                '#e74c3c', // red
                '#2ecc71', // green
                '#f1c40f', // yellow
                '#34495e', // dark blue
                '#ff69b4', // pink
                '#00b894', // light green
                '#fdcb6e', // light orange
              ]
              const boardOwnerId = parseInt('{{ board.owner.id }}')
              userColorMap[boardOwnerId] = '#3498db' // blue for owner
              let colorIdx = 0

              // First pass: assign colors to users
              data.nodes.forEach((node) => {
                const userId = node.created_by
                if (!(userId in userColorMap)) {
                  userColorMap[userId] =
                    colorPalette[colorIdx % colorPalette.length]
                  colorIdx++
                }
              })

              // Add nodes
              data.nodes.forEach((node) => {
                elements.push({
                  group: 'nodes',
                  data: {
                    id: node.id.toString(),
                    label: node.name,
                    description: node.description,
                    properties: node.properties || {},
                    created_by: node.created_by,
                    user_color: userColorMap[node.created_by],
                  },
                })
              })

              // Add edges
              data.edges.forEach((edge) => {
                elements.push({
                  group: 'edges',
                  data: {
                    id: `edge-${edge.from}-${edge.to}`,
                    source: edge.from.toString(),
                    target: edge.to.toString(),
                    label: edge.label || '',
                    created_by: edge.created_by,
                  },
                })
              })

              // Initialize or update cytoscape
              if (cy) {
                cy.destroy()
              }

              cy = cytoscape({
                container: document.getElementById('cy'),
                elements: elements,
                style: [
                  {
                    selector: 'node',
                    style: {
                      'background-color': 'data(user_color)',
                      'border-color': '#2980b9',
                      'border-width': 'data(borderWidth)',
                      label: 'data(label)',
                      'text-valign': 'center',
                      'text-halign': 'center',
                      'font-size': '10px',
                      color: '#fff',
                      'text-outline-color': 'data(user_color)',
                      'text-outline-width': '2px',
                      width: 'label',
                      height: 'label',
                      padding: '15px',
                      shape: 'ellipse',
                      'text-max-width': '100px',
                    },
                  },
                  {
                    selector: 'edge',
                    style: {
                      width: 1.5,
                      'line-color': '#95a5a6',
                      'target-arrow-color': '#95a5a6',
                      'target-arrow-shape': 'triangle',
                      'curve-style': 'bezier',
                      label: 'data(label)',
                      'font-size': '8px',
                      'text-rotation': 'autorotate',
                      'text-margin-y': '-10px',
                      'text-background-color': '#fff',
                      'text-background-opacity': 0.8,
                      'text-background-padding': '2px',
                    },
                  },
                  {
                    selector: '.selected',
                    style: {
                      'background-color': '#2ecc71',
                      'border-color': '#27ae60',
                      'line-color': '#2ecc71',
                      'target-arrow-color': '#2ecc71',
                      'text-outline-color': '#2ecc71',
                    },
                  },
                  {
                    selector: 'node:selected',
                    style: {
                      'border-width': '4px',
                      'border-color': '#f1c40f',
                      'border-opacity': 0.8,
                    },
                  },
                  {
                    selector: 'edge:selected',
                    style: {
                      width: 3,
                      'line-color': '#e74c3c',
                      'target-arrow-color': '#e74c3c',
                    },
                  },
                ],
                layout: {
                  name: 'cose',
                  idealEdgeLength: 150,
                  nodeOverlap: 20,
                  refresh: 20,
                  fit: true,
                  padding: 30,
                  randomize: false,
                  componentSpacing: 100,
                  nodeRepulsion: 500000,
                  edgeElasticity: 100,
                  nestingFactor: 5,
                  gravity: 80,
                  numIter: 1000,
                  initialTemp: 200,
                  coolingFactor: 0.95,
                  minTemp: 1.0,
                },
              })

              // Set borderWidth based on number of connections
              cy.nodes().forEach(function (node) {
                const degree = node.connectedEdges().length
                let borderWidth = 2
                if (degree >= 5) borderWidth = 6
                else if (degree >= 3) borderWidth = 4
                node.data('borderWidth', borderWidth)
              })

              // Update style to apply the new borderWidth
              cy.style()
                .selector('node')
                .style({ 'border-width': 'data(borderWidth)' })
                .update()

              // Overlay delete icon for nodes/edges the user can delete
              const currentUserId = parseInt('{{ user.id }}')

              // Find the #cy element
              const cyElement = document.getElementById('cy')
              cyElement.style.position = 'relative' // Ensure #cy is relative

              // Container for overlays
              let overlayContainer = document.getElementById('cy-overlays')
              if (!overlayContainer) {
                overlayContainer = document.createElement('div')
                overlayContainer.id = 'cy-overlays'
                overlayContainer.style.position = 'absolute'
                overlayContainer.style.top = '0'
                overlayContainer.style.left = '0'
                overlayContainer.style.width = '100%'
                overlayContainer.style.height = '100%'
                overlayContainer.style.pointerEvents = 'none'
                overlayContainer.style.zIndex = '1000'
                // Append as child to #cy
                cyElement.appendChild(overlayContainer)
              }

              function clearOverlays() {
                overlayContainer.innerHTML = ''
              }

              function addDeleteOverlayForNode(node) {
                const pos = node.renderedPosition()
                const cyRect = document
                  .getElementById('cy')
                  .getBoundingClientRect()
                const parentRect = overlayContainer.getBoundingClientRect()
                const offsetX = cyRect.left - parentRect.left
                const offsetY = cyRect.top - parentRect.top
                // X (delete) button
                const xBtn = document.createElement('div')
                xBtn.textContent = '×'
                xBtn.title = 'Delete node'
                xBtn.style.position = 'absolute'
                xBtn.style.left = pos.x + offsetX + 20 + 'px'
                xBtn.style.top = pos.y + offsetY - 20 + 'px'
                xBtn.style.width = '18px'
                xBtn.style.height = '18px'
                xBtn.style.background = '#fff'
                xBtn.style.color = '#e11d48'
                xBtn.style.border = '1px solid #e11d48'
                xBtn.style.borderRadius = '50%'
                xBtn.style.fontSize = '14px'
                xBtn.style.fontWeight = 'bold'
                xBtn.style.textAlign = 'center'
                xBtn.style.lineHeight = '18px'
                xBtn.style.cursor = 'pointer'
                xBtn.style.pointerEvents = 'auto'
                xBtn.style.zIndex = '1001'
                xBtn.onclick = function (e) {
                  e.stopPropagation()
                  if (confirm('Delete this node?')) {
                    window.location.href = `/node/${node.id()}/delete/`
                  }
                }
                overlayContainer.appendChild(xBtn)
                // Pen (edit) button
                const penBtn = document.createElement('div')
                penBtn.innerHTML =
                  '<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M12.146 2.854a.5.5 0 0 1 .708 0l.292.292a.5.5 0 0 1 0 .708l-8.5 8.5a.5.5 0 0 1-.168.11l-3 1a.5.5 0 0 1-.637-.637l1-3a.5.5 0 0 1 .11-.168l8.5-8.5zM11.207 3.5L3.5 11.207V12.5h1.293L12.5 4.793 11.207 3.5z" fill="#2563eb"/></svg>'
                penBtn.title = 'Edit node properties'
                penBtn.style.position = 'absolute'
                penBtn.style.left = pos.x + offsetX + 40 + 'px'
                penBtn.style.top = pos.y + offsetY - 20 + 'px'
                penBtn.style.width = '18px'
                penBtn.style.height = '18px'
                penBtn.style.background = '#fff'
                penBtn.style.border = '1px solid #2563eb'
                penBtn.style.borderRadius = '50%'
                penBtn.style.fontSize = '14px'
                penBtn.style.fontWeight = 'bold'
                penBtn.style.textAlign = 'center'
                penBtn.style.lineHeight = '18px'
                penBtn.style.cursor = 'pointer'
                penBtn.style.pointerEvents = 'auto'
                penBtn.style.zIndex = '1001'
                penBtn.style.display = 'flex'
                penBtn.style.alignItems = 'center'
                penBtn.style.justifyContent = 'center'
                penBtn.onclick = function (e) {
                  e.stopPropagation()
                  window.location.href = `/node/${node.id()}/`
                }
                overlayContainer.appendChild(penBtn)
              }

              // Only show edge overlays on click
              let currentEdgeOverlay = null

              function clearEdgeOverlay() {
                if (currentEdgeOverlay) {
                  currentEdgeOverlay.remove()
                  currentEdgeOverlay = null
                }
              }

              function addDeleteOverlayForEdge(edge) {
                const pos = edge.midpoint()
                const renderedPos = {
                  x: pos.x * cy.zoom() + cy.pan().x,
                  y: pos.y * cy.zoom() + cy.pan().y,
                }
                const overlayContainer = document.getElementById('cy-overlays')

                // Create container for edge buttons
                const edgeButtonsContainer = document.createElement('div')
                edgeButtonsContainer.style.position = 'absolute'
                edgeButtonsContainer.style.left = renderedPos.x + 'px'
                edgeButtonsContainer.style.top = renderedPos.y - 10 + 'px'
                edgeButtonsContainer.style.display = 'flex'
                edgeButtonsContainer.style.gap = '5px'
                edgeButtonsContainer.style.transform = 'translate(-50%, -100%)'
                edgeButtonsContainer.style.zIndex = '1001'

                // Delete button
                const xBtn = document.createElement('div')
                xBtn.className = 'edge-button delete-button'
                xBtn.innerHTML = '×'
                xBtn.title = 'Delete connection'
                xBtn.style.width = '20px'
                xBtn.style.height = '20px'
                xBtn.style.background = '#fff'
                xBtn.style.border = '1px solid #e74c3c'
                xBtn.style.borderRadius = '50%'
                xBtn.style.color = '#e74c3c'
                xBtn.style.fontSize = '16px'
                xBtn.style.fontWeight = 'bold'
                xBtn.style.textAlign = 'center'
                xBtn.style.lineHeight = '18px'
                xBtn.style.cursor = 'pointer'
                xBtn.style.pointerEvents = 'auto'
                xBtn.style.display = 'flex'
                xBtn.style.alignItems = 'center'
                xBtn.style.justifyContent = 'center'

                // Edit button
                const editBtn = document.createElement('div')
                editBtn.className = 'edge-button edit-button'
                editBtn.innerHTML = '✎'
                editBtn.title = 'Edit label'
                editBtn.style.width = '20px'
                editBtn.style.height = '20px'
                editBtn.style.background = '#fff'
                editBtn.style.border = '1px solid #2563eb'
                editBtn.style.borderRadius = '50%'
                editBtn.style.color = '#2563eb'
                editBtn.style.fontSize = '14px'
                editBtn.style.fontWeight = 'bold'
                editBtn.style.textAlign = 'center'
                editBtn.style.lineHeight = '20px'
                editBtn.style.cursor = 'pointer'
                editBtn.style.pointerEvents = 'auto'
                editBtn.style.display = 'flex'
                editBtn.style.alignItems = 'center'
                editBtn.style.justifyContent = 'center'

                // Delete button click handler
                xBtn.addEventListener('mousedown', function (e) {
                  e.stopPropagation()
                  e.preventDefault()
                  if (confirm('Delete this connection?')) {
                    const sourceNode = edge.data('source')
                    const targetNode = edge.data('target')
                    fetch('/api/edge/delete/', {
                      method: 'POST',
                      headers: {
                        'X-CSRFToken': csrfToken,
                        'Content-Type': 'application/x-www-form-urlencoded',
                      },
                      body: `from=${sourceNode}&to=${targetNode}&board=${boardId}`,
                    })
                      .then((response) => response.json())
                      .then((data) => {
                        if (data.status === 'deleted') {
                          cy.remove(edge)
                          clearEdgeOverlay()
                        } else {
                          alert(data.message || 'Failed to delete connection')
                        }
                      })
                      .catch((error) => {
                        console.error('Delete error:', error)
                        alert('Failed to delete connection: ' + error.message)
                      })
                  }
                })

                // Edit button click handler
                editBtn.addEventListener('mousedown', function (e) {
                  e.stopPropagation()
                  e.preventDefault()
                  const currentLabel = edge.data('label') || ''
                  const newLabel = prompt(
                    'Enter new label for this connection:',
                    currentLabel,
                  )

                  if (newLabel !== null && newLabel !== currentLabel) {
                    const sourceNode = edge.data('source')
                    const targetNode = edge.data('target')
                    fetch('/api/edge/update/', {
                      method: 'POST',
                      headers: {
                        'X-CSRFToken': csrfToken,
                        'Content-Type': 'application/x-www-form-urlencoded',
                      },
                      body: `from=${sourceNode}&to=${targetNode}&board=${boardId}&label=${encodeURIComponent(
                        newLabel,
                      )}`,
                    })
                      .then((response) => response.json())
                      .then((data) => {
                        if (data.status === 'ok') {
                          edge.data('label', newLabel)
                          clearEdgeOverlay()
                          // Reload the graph to ensure everything is in sync
                          loadGraph()
                        } else {
                          alert(data.message || 'Failed to update label')
                        }
                      })
                      .catch((error) => {
                        console.error('Update error:', error)
                        alert('Failed to update label: ' + error.message)
                      })
                  }
                })

                edgeButtonsContainer.appendChild(editBtn)
                edgeButtonsContainer.appendChild(xBtn)
                overlayContainer.appendChild(edgeButtonsContainer)
                currentEdgeOverlay = edgeButtonsContainer
              }

              function addAllOverlays() {
                clearOverlays()
                cy.nodes().forEach(function (node) {
                  const data = node.data()
                  if (
                    currentUserId !== boardOwnerId &&
                    data.created_by === currentUserId
                  ) {
                    addDeleteOverlayForNode(node)
                  }
                })
                // Do not add edge overlays here
              }

              cy.on('zoom pan resize', function () {
                addAllOverlays()
                clearEdgeOverlay()
              })

              cy.on('position', 'node', function () {
                addAllOverlays()
                clearEdgeOverlay()
              })

              cy.on('tap', function (event) {
                if (event.target === cy) {
                  clearEdgeOverlay()
                }
              })

              cy.on('tap', 'node', function () {
                clearEdgeOverlay()
              })

              cy.on('tap', 'edge', function (evt) {
                clearEdgeOverlay()
                const edge = evt.target
                const data = edge.data()
                if (
                  currentUserId === boardOwnerId ||
                  data.created_by === currentUserId
                ) {
                  addDeleteOverlayForEdge(edge)
                }
              })

              cy.ready(function () {
                addAllOverlays()
                clearEdgeOverlay()
              })

              // Node click handler
              cy.on('tap', 'node', function (evt) {
                const node = evt.target
                const nodeData = node.data()

                if (isConnectMode) {
                  if (!selectedNode) {
                    selectedNode = node
                    node.addClass('selected')
                  } else {
                    const fromId = selectedNode.id()
                    const toId = node.id()

                    // Prevent self-connections
                    if (fromId === toId) {
                      alert('Cannot connect a node to itself!')
                      selectedNode.removeClass('selected')
                      selectedNode = null
                      return
                    }

                    const label = prompt(
                      'Enter a label for this connection (optional):',
                    )

                    fetch('/api/edge/add/', {
                      method: 'POST',
                      headers: {
                        'X-CSRFToken': csrfToken,
                        'Content-Type': 'application/x-www-form-urlencoded',
                      },
                      credentials: 'include',
                      body: `from=${fromId}&to=${toId}&board=${boardId}&label=${encodeURIComponent(
                        label || '',
                      )}`,
                    })
                      .then((response) => {
                        if (!response.ok)
                          throw new Error('Network response was not ok')
                        return response.json()
                      })
                      .then((data) => {
                        if (data.status === 'ok') {
                          loadGraph()
                        } else {
                          throw new Error('Failed to create connection')
                        }
                      })
                      .catch((error) => {
                        console.error('Error:', error)
                        alert('Failed to create connection')
                      })
                      .finally(() => {
                        selectedNode.removeClass('selected')
                        selectedNode = null
                      })
                  }
                } else {
                  // Show node details in modal
                  document.getElementById('nodeName').textContent =
                    nodeData.label
                  const propertiesDiv = document.getElementById(
                    'nodeProperties',
                  )
                  propertiesDiv.innerHTML = ''

                  // Add description if available
                  if (nodeData.description) {
                    const descDiv = document.createElement('div')
                    descDiv.className = 'node-description-modal'
                    descDiv.textContent = nodeData.description
                    descDiv.style.marginBottom = '16px'
                    descDiv.style.fontStyle = 'italic'
                    descDiv.style.color = '#444'
                    propertiesDiv.appendChild(descDiv)
                  }

                  if (
                    nodeData.properties &&
                    Object.keys(nodeData.properties).length > 0
                  ) {
                    for (const [key, value] of Object.entries(
                      nodeData.properties,
                    )) {
                      const propertyItem = document.createElement('div')
                      propertyItem.className = 'property-item'
                      propertyItem.innerHTML = `<strong>${key}:</strong> ${value}`
                      propertiesDiv.appendChild(propertyItem)
                    }
                  } else {
                    propertiesDiv.innerHTML += '<p>No properties available.</p>'
                  }

                  modal.style.display = 'block'
                }
              })

              // Edge click handler
              cy.on('tap', 'edge', function (evt) {
                evt.preventDefault()
                const edge = evt.target

                // Clear any previously selected edge
                cy.edges().removeClass('selected')
                clearSelectedEdge()

                // Select the new edge
                selectedEdge = edge
                edge.addClass('selected')
                if (deleteEdgeBtn) deleteEdgeBtn.classList.add('active')
              })

              // Background click handler
              cy.on('tap', function (event) {
                if (event.target === cy) {
                  if (selectedNode) {
                    selectedNode.removeClass('selected')
                    selectedNode = null
                  }
                  clearSelectedEdge()
                }
              })
            })
            .catch((error) => {
              console.error('Error loading graph data:', error)
              alert('Failed to load graph data: ' + error.message)
            })
        }

        // Start in view mode and load the graph
        if (viewModeBtn) viewModeBtn.click()
        loadGraph()

        // Reload graph when nodes are added or deleted
        const createNodeLink = document.querySelector('a[href*="create_node"]')
        const deleteNodeLinks = document.querySelectorAll(
          'a[href*="delete_node"]',
        )

        if (createNodeLink) {
          createNodeLink.addEventListener('click', function () {
            setTimeout(function () {
              window.location.reload() // Reload the page to update both graph and node list
            }, 1000)
          })
        }

        deleteNodeLinks.forEach((link) => {
          link.addEventListener('click', function () {
            setTimeout(loadGraph, 1000) // Reload after node deletion
          })
        })

        // Accordion logic for nodes
        const header = document.getElementById('nodesAccordionHeader')
        const content = document.getElementById('nodesAccordionContent')
        if (header && content) {
          header.addEventListener('click', function () {
            header.classList.toggle('collapsed')
            content.classList.toggle('open')
            header.querySelector(
              '.arrow',
            ).style.transform = content.classList.contains('open')
              ? 'rotate(90deg)'
              : 'rotate(0deg)'
          })
        }

        var askEditBtn = document.getElementById('askEditBtn')
        var askEditModal = document.getElementById('askEditModal')
        var closeAskEdit = document.getElementById('closeAskEdit')
        var sendEditRequest = document.getElementById('sendEditRequest')
        var editRequestSentMsg = document.getElementById('editRequestSentMsg')
        var editRequestStatusArea = document.getElementById(
          'editRequestStatusArea',
        )
        if (
          askEditBtn &&
          askEditModal &&
          closeAskEdit &&
          sendEditRequest &&
          editRequestSentMsg &&
          editRequestStatusArea
        ) {
          askEditBtn.onclick = function () {
            askEditModal.style.display = 'block'
          }
          closeAskEdit.onclick = function () {
            askEditModal.style.display = 'none'
          }
          window.onclick = function (event) {
            if (event.target == askEditModal) {
              askEditModal.style.display = 'none'
            }
          }
          sendEditRequest.onclick = function () {
            const message = document.getElementById('editRequestMsg').value
            if (!message) {
              alert('Please enter a message.')
              return
            }
            fetch(`/api/board/${boardId}/request_edit/`, {
              method: 'POST',
              headers: {
                'Content-Type': 'application/json',
                'X-CSRFToken': csrfToken,
              },
              body: JSON.stringify({ message: message }),
            })
              .then((response) => response.json())
              .then((data) => {
                if (data.status === 'ok') {
                  askEditModal.style.display = 'none'
                  // Show the message in the same area and disable the button
                  editRequestStatusArea.innerHTML = `<div style='color:#10b981;margin:16px 0;'>Your message was sent, please wait for accept.</div><button class='ask-edit-btn' id='askEditBtn' disabled style='opacity:0.6;cursor:not-allowed;'>Ask for Edit</button>`
                } else {
                  alert(data.message || 'Failed to send request.')
                }
              })
              .catch((error) => {
                console.error('Error:', error)
                alert('Failed to send request.')
              })
          }
        }

        document.getElementById('send-btn').onclick = function () {
          const text = document.getElementById('chat-text').value.trim()
          if (!text) return
          fetch("{% url 'post_message' board.id %}", {
            method: 'POST',
            headers: {
              'X-CSRFToken': '{{ csrf_token }}',
              'Content-Type': 'application/x-www-form-urlencoded',
            },
            body: 'content=' + encodeURIComponent(text),
          })
            .then((response) => response.json())
            .then((data) => {
              if (data.id) {
                location.reload()
              }
            })
        }

        // Remove old edit/delete handlers
        // Add event delegation for chat-feed
        const chatFeed = document.getElementById('chat-feed')
        if (chatFeed) {
          chatFeed.onclick = function (e) {
            const target = e.target
            // Edit button
            if (target.classList.contains('edit-btn')) {
              const msgDiv = target.closest('.chat-message')
              const contentSpan = msgDiv.querySelector('.chat-content')
              const oldContent = contentSpan.textContent
              contentSpan.innerHTML = `<textarea class="edit-area">${oldContent}</textarea>
                <button class="save-edit">Save</button>
                <button class="cancel-edit">Cancel</button>`
              msgDiv.querySelector('.save-edit').onclick = function () {
                const newContent = msgDiv
                  .querySelector('.edit-area')
                  .value.trim()
                fetch(`/api/messages/${msgDiv.dataset.id}/edit/`, {
                  method: 'POST',
                  headers: {
                    'X-CSRFToken': '{{ csrf_token }}',
                    'Content-Type': 'application/x-www-form-urlencoded',
                  },
                  body: 'content=' + encodeURIComponent(newContent),
                })
                  .then((response) => response.json())
                  .then((data) => {
                    if (data.success) {
                      contentSpan.textContent = data.content
                    }
                  })
              }
              msgDiv.querySelector('.cancel-edit').onclick = function () {
                contentSpan.textContent = oldContent
              }
            }
            // Delete button
            if (target.classList.contains('delete-btn')) {
              if (!confirm('Delete this message?')) return
              const msgDiv = target.closest('.chat-message')
              fetch(`/api/messages/${msgDiv.dataset.id}/delete/`, {
                method: 'POST',
                headers: {
                  'X-CSRFToken': '{{ csrf_token }}',
                },
              })
                .then((response) => response.json())
                .then((data) => {
                  if (data.success) {
                    msgDiv.remove()
                  }
                })
            }
          }
        }

        function setChatSidebar(open) {
          var sidebar = document.querySelector('.chat-sidebar')
          var closeBtn = document.getElementById('close-chat-btn')
          var openBtn = document.getElementById('open-chat-btn')
          if (!sidebar) return
          if (window.innerWidth >= 1200) {
            sidebar.classList.remove('open')
            if (closeBtn) closeBtn.style.display = 'none'
            if (openBtn) openBtn.style.display = 'none'
            document.body.classList.remove('chat-open')
            return
          }
          if (open) {
            sidebar.classList.add('open')
            if (openBtn) openBtn.style.display = 'none'
            if (closeBtn) closeBtn.style.display = 'block'
            document.body.classList.add('chat-open')
          } else {
            sidebar.classList.remove('open')
            if (openBtn) openBtn.style.display = 'flex'
            if (closeBtn) closeBtn.style.display = 'none'
            document.body.classList.remove('chat-open')
          }
        }
        document.getElementById('open-chat-btn').onclick = function () {
          setChatSidebar(true)
        }
        window.addEventListener('DOMContentLoaded', function () {
          var chatHeader = document.querySelector('.chat-header')
          if (chatHeader && !document.getElementById('close-chat-btn')) {
            var btn = document.createElement('button')
            btn.id = 'close-chat-btn'
            btn.className = 'close-chat-btn'
            btn.innerHTML = '✕'
            btn.style.display = 'none'
            btn.onclick = function () {
              setChatSidebar(false)
            }
            chatHeader.appendChild(btn)
          }
          setChatSidebar(window.innerWidth < 1200 ? false : true)
        })
        window.addEventListener('resize', function () {
          setChatSidebar(window.innerWidth < 1200 ? false : true)
        })
      })
    </script>
  </body>
</html>
